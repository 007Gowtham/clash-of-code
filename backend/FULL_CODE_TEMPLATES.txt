üîç Fetching all questions with complete templates...

üìö Showing 15 questions


====================================================================================================
üìù QUESTION: Longest Palindromic Substring (longest-palindromic-substring-9)
   Difficulty: MEDIUM | Points: 250
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
string longestPalindrome(string s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = longestPalindrome();
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static String longestPalindrome(String s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        String result = longestPalindrome();
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function longestPalindrome(s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = longestPalindrome();
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def longestPalindrome(s: str) -> str:
    # TODO: Implement your solution here
    return ""

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = longestPalindrome()
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Two Sum (two-sum-3)
   Difficulty: EASY | Points: 100
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<int> twoSum(vector<int>& nums, int target) {
    // TODO: Implement your solution here
    return {};
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    int arg1;
    cin >> arg1;
    
    // Call user function
    auto result = twoSum(arg0, arg1);
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[] twoSum(int[] nums, int target) {
    // TODO: Implement your solution here
    return new int[0];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        int arg1 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        int[] result = twoSum(arg0, arg1);
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function twoSum(nums, target) {
    // TODO: Implement your solution here
    return [];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    const arg1 = readInt();
    
    // Call user function
    const result = twoSum(arg0, arg1);
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def twoSum(nums: List[int], target: int) -> List[int]:
    # TODO: Implement your solution here
    return []

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    arg1 = read_int()
    
    # Call user function
    result = twoSum(arg0, arg1)
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Binary Tree Level Order Traversal (binary-tree-level-order-traversal-3)
   Difficulty: MEDIUM | Points: 200
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<vector<int>> levelOrder(TreeNode* root) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = levelOrder();
    
    // Serialize and print output
    cout << serializeTree(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[][] levelOrder(TreeNode root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        int[][] result = levelOrder();
        
        // Serialize and print output
        System.out.println(serializeTree(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function levelOrder(root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = levelOrder();
    
    // Serialize and print output
    console.log(serializeTree(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def levelOrder(root: Optional[TreeNode]) -> List[List[int]]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = levelOrder()
    
    # Serialize and print output
    print(serialize_tree(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Reverse Linked List (reverse-linked-list-7)
   Difficulty: EASY | Points: 150
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* reverseList(ListNode* head) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = reverseList();
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode reverseList(ListNode head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        ListNode result = reverseList();
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function reverseList(head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = reverseList();
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = reverseList()
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Merge K Sorted Lists (merge-k-sorted-lists-6)
   Difficulty: HARD | Points: 400
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* mergeKLists(vector<ListNode*>& lists) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    
    // Call user function
    auto result = mergeKLists(arg0);
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode mergeKLists(int lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        ListNode result = mergeKLists(arg0);
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function mergeKLists(lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    
    // Call user function
    const result = mergeKLists(arg0);
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def mergeKLists(lists: Any) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    
    # Call user function
    result = mergeKLists(arg0)
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Two Sum (two-sum-2)
   Difficulty: EASY | Points: 100
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<int> twoSum(vector<int>& nums, int target) {
    // TODO: Implement your solution here
    return {};
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    int arg1;
    cin >> arg1;
    
    // Call user function
    auto result = twoSum(arg0, arg1);
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[] twoSum(int[] nums, int target) {
    // TODO: Implement your solution here
    return new int[0];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        int arg1 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        int[] result = twoSum(arg0, arg1);
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function twoSum(nums, target) {
    // TODO: Implement your solution here
    return [];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    const arg1 = readInt();
    
    // Call user function
    const result = twoSum(arg0, arg1);
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def twoSum(nums: List[int], target: int) -> List[int]:
    # TODO: Implement your solution here
    return []

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    arg1 = read_int()
    
    # Call user function
    result = twoSum(arg0, arg1)
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Reverse Linked List (reverse-linked-list-2)
   Difficulty: EASY | Points: 150
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* reverseList(ListNode* head) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = reverseList();
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode reverseList(ListNode head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        ListNode result = reverseList();
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function reverseList(head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = reverseList();
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = reverseList()
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Longest Palindromic Substring (longest-palindromic-substring-4)
   Difficulty: MEDIUM | Points: 250
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
string longestPalindrome(string s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = longestPalindrome();
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static String longestPalindrome(String s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        String result = longestPalindrome();
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function longestPalindrome(s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = longestPalindrome();
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def longestPalindrome(s: str) -> str:
    # TODO: Implement your solution here
    return ""

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = longestPalindrome()
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Binary Tree Level Order Traversal (binary-tree-level-order-traversal-1)
   Difficulty: MEDIUM | Points: 200
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<vector<int>> levelOrder(TreeNode* root) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = levelOrder();
    
    // Serialize and print output
    cout << serializeTree(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[][] levelOrder(TreeNode root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        int[][] result = levelOrder();
        
        // Serialize and print output
        System.out.println(serializeTree(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function levelOrder(root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = levelOrder();
    
    // Serialize and print output
    console.log(serializeTree(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def levelOrder(root: Optional[TreeNode]) -> List[List[int]]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = levelOrder()
    
    # Serialize and print output
    print(serialize_tree(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Merge K Sorted Lists (merge-k-sorted-lists-2)
   Difficulty: HARD | Points: 400
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* mergeKLists(vector<ListNode*>& lists) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    
    // Call user function
    auto result = mergeKLists(arg0);
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode mergeKLists(int lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        ListNode result = mergeKLists(arg0);
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function mergeKLists(lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    
    // Call user function
    const result = mergeKLists(arg0);
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def mergeKLists(lists: Any) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    
    # Call user function
    result = mergeKLists(arg0)
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Merge K Sorted Lists (merge-k-sorted-lists-4)
   Difficulty: HARD | Points: 400
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* mergeKLists(vector<ListNode*>& lists) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    
    // Call user function
    auto result = mergeKLists(arg0);
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode mergeKLists(int lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        ListNode result = mergeKLists(arg0);
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function mergeKLists(lists) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    
    // Call user function
    const result = mergeKLists(arg0);
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def mergeKLists(lists: Any) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    
    # Call user function
    result = mergeKLists(arg0)
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Two Sum (two-sum-4)
   Difficulty: EASY | Points: 100
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<int> twoSum(vector<int>& nums, int target) {
    // TODO: Implement your solution here
    return {};
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs
    int arg0;
    cin >> arg0;
    int arg1;
    cin >> arg1;
    
    // Call user function
    auto result = twoSum(arg0, arg1);
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[] twoSum(int[] nums, int target) {
    // TODO: Implement your solution here
    return new int[0];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs
        int arg0 = Integer.parseInt(br.readLine().trim());
        int arg1 = Integer.parseInt(br.readLine().trim());
        
        // Call user function
        int[] result = twoSum(arg0, arg1);
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function twoSum(nums, target) {
    // TODO: Implement your solution here
    return [];
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs
    const arg0 = readLine();
    const arg1 = readInt();
    
    // Call user function
    const result = twoSum(arg0, arg1);
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def twoSum(nums: List[int], target: int) -> List[int]:
    # TODO: Implement your solution here
    return []

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs
    arg0 = read_line()
    arg1 = read_int()
    
    # Call user function
    result = twoSum(arg0, arg1)
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Binary Tree Level Order Traversal (binary-tree-level-order-traversal-5)
   Difficulty: MEDIUM | Points: 200
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
vector<vector<int>> levelOrder(TreeNode* root) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = levelOrder();
    
    // Serialize and print output
    cout << serializeTree(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static int[][] levelOrder(TreeNode root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        int[][] result = levelOrder();
        
        // Serialize and print output
        System.out.println(serializeTree(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function levelOrder(root) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = levelOrder();
    
    // Serialize and print output
    console.log(serializeTree(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def levelOrder(root: Optional[TreeNode]) -> List[List[int]]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = levelOrder()
    
    # Serialize and print output
    print(serialize_tree(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Reverse Linked List (reverse-linked-list-3)
   Difficulty: EASY | Points: 150
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
ListNode* reverseList(ListNode* head) {
    // TODO: Implement your solution here
    return nullptr;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = reverseList();
    
    // Serialize and print output
    cout << serializeLinkedList(result) << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static ListNode reverseList(ListNode head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        ListNode result = reverseList();
        
        // Serialize and print output
        System.out.println(serializeLinkedList(result));
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function reverseList(head) {
    // TODO: Implement your solution here
    return null;
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = reverseList();
    
    // Serialize and print output
    console.log(serializeLinkedList(result));
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def reverseList(head: Optional[ListNode]) -> Optional[ListNode]:
    # TODO: Implement your solution here
    return None

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = reverseList()
    
    # Serialize and print output
    print(serialize_linked_list(result))

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

====================================================================================================
üìù QUESTION: Longest Palindromic Substring (longest-palindromic-substring)
   Difficulty: MEDIUM | Points: 250
====================================================================================================

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: CPP
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
string longestPalindrome(string s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    
    // Parse inputs

    
    // Call user function
    auto result = longestPalindrome();
    
    // Serialize and print output
    cout << result << endl;
    
    return 0;
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

// Data Structures (MUST be defined first)
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Helper Functions (use structs defined above)
TreeNode* parseTree(vector<string>& tokens) {
    if (tokens.empty() || tokens[0] == "null") return nullptr;
    
    TreeNode* root = new TreeNode(stoi(tokens[0]));
    queue<TreeNode*> q;
    q.push(root);
    int i = 1;
    
    while (!q.empty() && i < tokens.size()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->left = new TreeNode(stoi(tokens[i]));
            q.push(node->left);
        }
        i++;
        
        if (i < tokens.size() && tokens[i] != "null") {
            node->right = new TreeNode(stoi(tokens[i]));
            q.push(node->right);
        }
        i++;
    }
    
    return root;
}

ListNode* parseLinkedList() {
    int n;
    cin >> n;
    
    if (n <= 0) return nullptr;
    
    vector<int> vals(n);
    for (int i = 0; i < n; i++) cin >> vals[i];
    
    if (vals.empty()) return nullptr;
    
    ListNode* head = new ListNode(vals[0]);
    ListNode* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new ListNode(vals[i]);
        curr = curr->next;
    }
    return head;
}

vector<vector<int>> parseGraph(bool isDirected = false) {
    int n, m;
    cin >> n >> m;
    
    if (n <= 0) return {};
    
    vector<vector<int>> graph(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        if (!isDirected) graph[v].push_back(u);
    }
    
    return graph;
}

string serializeArray(vector<int>& arr) {
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < arr.size(); i++) {
        if (i > 0) oss << ",";
        oss << arr[i];
    }
    oss << "]";
    return oss.str();
}

string serializeMatrix(vector<vector<int>>& matrix) {
    if (matrix.empty()) return "[]";
    
    ostringstream oss;
    oss << "[";
    for (size_t i = 0; i < matrix.size(); i++) {
        if (i > 0) oss << ",";
        oss << "[";
        for (size_t j = 0; j < matrix[i].size(); j++) {
            if (j > 0) oss << ",";
            oss << matrix[i][j];
        }
        oss << "]";
    }
    oss << "]";
    return oss.str();
}

string serializeTree(TreeNode* root) {
    if (!root) return "[]";
    
    ostringstream oss;
    vector<string> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        if (node) {
            result.push_back(to_string(node->val));
            q.push(node->left);
            q.push(node->right);
        } else {
            result.push_back("null");
        }
    }
    
    // Trim trailing nulls
    while (!result.empty() && result.back() == "null") {
        result.pop_back();
    }
    
    oss << "[";
    for (size_t i = 0; i < result.size(); i++) {
        if (i > 0) oss << ",";
        oss << result[i];
    }
    oss << "]";
    return oss.str();
}

string serializeLinkedList(ListNode* head) {
    vector<int> result;
    ListNode* curr = head;
    
    while (curr) {
        result.push_back(curr->val);
        curr = curr->next;
    }
    
    return serializeArray(result);
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVA
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

üìê DEFINITIONS:
--------------------------------------------------------------------------------
static class ListNode {
    int val;
    ListNode next;
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

static class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

static TreeNode parseTree(String[] tokens) {
    if (tokens.length == 0 || tokens[0].equals("null")) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int i = 1;
    
    while (!queue.isEmpty() && i < tokens.length) {
        TreeNode node = queue.poll();
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.left = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.left);
        }
        i++;
        
        if (i < tokens.length && !tokens[i].equals("null")) {
            node.right = new TreeNode(Integer.parseInt(tokens[i]));
            queue.offer(node.right);
        }
        i++;
    }
    
    return root;
}

static ListNode parseLinkedList(BufferedReader br) throws IOException {
    int n = Integer.parseInt(br.readLine());
    if (n <= 0) return null;
    
    String[] vals = br.readLine().split(" ");
    if (vals.length == 0) return null;
    
    ListNode head = new ListNode(Integer.parseInt(vals[0]));
    ListNode curr = head;
    
    for (int i = 1; i < n; i++) {
        curr.next = new ListNode(Integer.parseInt(vals[i]));
        curr = curr.next;
    }
    
    return head;
}

static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
    int n = Integer.parseInt(br.readLine());
    int m = Integer.parseInt(br.readLine());
    
    if (n <= 0) return new ArrayList<>();
    
    List<List<Integer>> graph = new ArrayList<>();
    for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
    
    for (int i = 0; i < m; i++) {
        String[] edge = br.readLine().split(" ");
        int u = Integer.parseInt(edge[0]);
        int v = Integer.parseInt(edge[1]);
        graph.get(u).add(v);
        if (!isDirected) graph.get(v).add(u);
    }
    
    return graph;
}

static String serializeArray(int[] arr) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < arr.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(arr[i]);
    }
    sb.append("]");
    return sb.toString();
}

static String serializeList(List<Integer> list) {
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < list.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(list.get(i));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeMatrix(int[][] matrix) {
    if (matrix.length == 0) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.length; i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeArray(matrix[i]));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeListMatrix(List<List<Integer>> matrix) {
    if (matrix.isEmpty()) return "[]";
    StringBuilder sb = new StringBuilder("[");
    for (int i = 0; i < matrix.size(); i++) {
        if (i > 0) sb.append(",");
        sb.append(serializeList(matrix.get(i)));
    }
    sb.append("]");
    return sb.toString();
}

static String serializeTree(TreeNode root) {
    if (root == null) return "[]";
    
    List<String> result = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node != null) {
            result.add(String.valueOf(node.val));
            queue.offer(node.left);
            queue.offer(node.right);
        } else {
            result.add("null");
        }
    }
    
    while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
        result.remove(result.size() - 1);
    }
    
    return "[" + String.join(",", result) + "]";
}

static String serializeLinkedList(ListNode head) {
    List<Integer> result = new ArrayList<>();
    ListNode curr = head;
    
    while (curr != null) {
        result.add(curr.val);
        curr = curr.next;
    }
    
    return serializeList(result);
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
public static String longestPalindrome(String s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
public class Main {
    // *** DEFINITION INJECTED HERE WITH INDENTATION ***
    
    // *** USER FUNCTION INJECTED HERE WITH INDENTATION ***
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        // Parse inputs

        
        // Call user function
        String result = longestPalindrome();
        
        // Serialize and print output
        System.out.println(result);
    }
}

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import java.io.*;
import java.util.*;

public class Main {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) {
            this.val = val;
            this.next = null;
        }
    }

    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    static TreeNode parseTree(String[] tokens) {
        if (tokens.length == 0 || tokens[0].equals("null")) return null;
        
        TreeNode root = new TreeNode(Integer.parseInt(tokens[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        
        while (!queue.isEmpty() && i < tokens.length) {
            TreeNode node = queue.poll();
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.left);
            }
            i++;
            
            if (i < tokens.length && !tokens[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(tokens[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }

    static ListNode parseLinkedList(BufferedReader br) throws IOException {
        int n = Integer.parseInt(br.readLine());
        if (n <= 0) return null;
        
        String[] vals = br.readLine().split(" ");
        if (vals.length == 0) return null;
        
        ListNode head = new ListNode(Integer.parseInt(vals[0]));
        ListNode curr = head;
        
        for (int i = 1; i < n; i++) {
            curr.next = new ListNode(Integer.parseInt(vals[i]));
            curr = curr.next;
        }
        
        return head;
    }

    static List<List<Integer>> parseGraph(BufferedReader br, boolean isDirected) throws IOException {
        int n = Integer.parseInt(br.readLine());
        int m = Integer.parseInt(br.readLine());
        
        if (n <= 0) return new ArrayList<>();
        
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        
        for (int i = 0; i < m; i++) {
            String[] edge = br.readLine().split(" ");
            int u = Integer.parseInt(edge[0]);
            int v = Integer.parseInt(edge[1]);
            graph.get(u).add(v);
            if (!isDirected) graph.get(v).add(u);
        }
        
        return graph;
    }

    static String serializeArray(int[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(arr[i]);
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeList(List<Integer> list) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < list.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(list.get(i));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeMatrix(int[][] matrix) {
        if (matrix.length == 0) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeArray(matrix[i]));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeListMatrix(List<List<Integer>> matrix) {
        if (matrix.isEmpty()) return "[]";
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < matrix.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(serializeList(matrix.get(i)));
        }
        sb.append("]");
        return sb.toString();
    }

    static String serializeTree(TreeNode root) {
        if (root == null) return "[]";
        
        List<String> result = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            if (node != null) {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                result.add("null");
            }
        }
        
        while (!result.isEmpty() && result.get(result.size() - 1).equals("null")) {
            result.remove(result.size() - 1);
        }
        
        return "[" + String.join(",", result) + "]";
    }

    static String serializeLinkedList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        ListNode curr = head;
        
        while (curr != null) {
            result.add(curr.val);
            curr = curr.next;
        }
        
        return serializeList(result);
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: JAVASCRIPT
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
function longestPalindrome(s) {
    // TODO: Implement your solution here
    return "";
}

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
function main() {
    // Parse inputs

    
    // Call user function
    const result = longestPalindrome();
    
    // Serialize and print output
    console.log(result);
}

main();

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
const fs = require('fs');
const input = fs.readFileSync(0, 'utf8').trim().split('\n');
let lineIndex = 0;

function readLine() {
    return lineIndex < input.length ? input[lineIndex++] : "";
}

function readInt() {
    return parseInt(readLine());
}

function readIntArray(n) {
    return readLine().split(' ').map(Number);
}

function readMatrix(rows, cols) {
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        matrix.push(readLine().split(' ').map(Number));
    }
    return matrix;
}

function parseTree() {
    const tokens = readLine().split(' ');
    
    if (!tokens.length || tokens[0] === "null") return null;
    
    const root = new TreeNode(parseInt(tokens[0]));
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue for O(1) performance
    let i = 1;
    
    while (qIndex < queue.length && i < tokens.length) {
        const node = queue[qIndex++];
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.left = new TreeNode(parseInt(tokens[i]));
            queue.push(node.left);
        }
        i++;
        
        if (i < tokens.length && tokens[i] !== "null") {
            node.right = new TreeNode(parseInt(tokens[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

function parseLinkedList() {
    const n = readInt();
    
    if (n <= 0) return null;
    
    const values = readIntArray(n);
    
    if (!values || values.length === 0) return null;
    
    const head = new ListNode(values[0]);
    let current = head;
    
    for (let i = 1; i < n; i++) {
        current.next = new ListNode(values[i]);
        current = current.next;
    }
    
    return head;
}

function parseGraph(isDirected = false) {
    const n = readInt();
    const m = readInt();
    
    if (n <= 0) return [];
    
    const graph = Array.from({length: n}, () => []);
    
    for (let i = 0; i < m; i++) {
        const [u, v] = readLine().split(' ').map(Number);
        graph[u].push(v);
        if (!isDirected) graph[v].push(u);
    }
    
    return graph;
}

function serializeArray(arr) {
    return '[' + arr.join(',') + ']';
}

function serializeMatrix(matrix) {
    if (!matrix || matrix.length === 0) return "[]";
    return '[' + matrix.map(row => '[' + row.join(',') + ']').join(',') + ']';
}

function serializeTree(root) {
    if (!root) return "[]";
    
    const result = [];
    const queue = [root];
    let qIndex = 0;  // FIXED: Index-based queue
    
    while (qIndex < queue.length) {
        const node = queue[qIndex++];
        
        if (node) {
            result.push(node.val);
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Trim trailing nulls
    while (result.length && result[result.length - 1] === "null") {
        result.pop();
    }
    
    return '[' + result.join(',') + ']';
}

function serializeLinkedList(head) {
    const result = [];
    let current = head;
    
    while (current) {
        result.push(current.val);
        current = current.next;
    }
    
    return '[' + result.join(',') + ']';
}

class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤

‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº
üîπ LANGUAGE: PYTHON
‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº‚ñº

üì¶ HEADER CODE:
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

üìê DEFINITIONS:
--------------------------------------------------------------------------------
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚úèÔ∏è  USER FUNCTION (Editable):
--------------------------------------------------------------------------------
def longestPalindrome(s: str) -> str:
    # TODO: Implement your solution here
    return ""

üöÄ MAIN FUNCTION (Driver Code):
--------------------------------------------------------------------------------
def main():
    # Parse inputs

    
    # Call user function
    result = longestPalindrome()
    
    # Serialize and print output
    print(result)

if __name__ == "__main__":
    main()

üìã BOILERPLATE (Combined):
--------------------------------------------------------------------------------
import sys
from collections import deque, defaultdict
from typing import List, Optional

# Read all input upfront
data = sys.stdin.read().strip().split('\n')
idx = [0]

def read_line():
    # FIXED: Bounds checking to prevent IndexError
    if idx[0] >= len(data):
        return ""
    line = data[idx[0]]
    idx[0] += 1
    return line

def read_int():
    line = read_line()
    return int(line) if line else 0

def read_int_array(n):
    return list(map(int, read_line().split()))

def read_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        matrix.append(list(map(int, read_line().split())))
    return matrix

def parse_tree():
    tokens = read_line().split()
    
    if not tokens or tokens[0] == "null":
        return None
    
    root = TreeNode(int(tokens[0]))
    queue = deque([root])
    i = 1
    
    while queue and i < len(tokens):
        node = queue.popleft()
        
        if i < len(tokens) and tokens[i] != "null":
            node.left = TreeNode(int(tokens[i]))
            queue.append(node.left)
        i += 1
        
        if i < len(tokens) and tokens[i] != "null":
            node.right = TreeNode(int(tokens[i]))
            queue.append(node.right)
        i += 1
    
    return root

def parse_linked_list():
    n = read_int()
    
    if n <= 0:
        return None
    
    values = read_int_array(n)
    
    if not values:
        return None
    
    head = ListNode(values[0])
    current = head
    
    for i in range(1, n):
        current.next = ListNode(values[i])
        current = current.next
    
    return head

def parse_graph(is_directed=False):
    n = read_int()
    m = read_int()
    
    if n <= 0:
        return []
    
    graph = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = map(int, read_line().split())
        graph[u].append(v)
        if not is_directed:
            graph[v].append(u)
    
    return graph

def serialize_array(arr):
    return '[' + ','.join(map(str, arr)) + ']'

def serialize_matrix(matrix):
    # FIXED: Handle empty matrix
    if not matrix:
        return "[]"
    return '[' + ','.join('[' + ','.join(map(str, row)) + ']' for row in matrix) + ']'

def serialize_tree(root):
    if not root:
        return "[]"
    
    result = []
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("null")
    
    # Trim trailing nulls
    while result and result[-1] == "null":
        result.pop()
    
    return '[' + ','.join(result) + ']'

def serialize_linked_list(head):
    result = []
    current = head
    
    while current:
        result.append(str(current.val))
        current = current.next
    
    return '[' + ','.join(result) + ']'

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤‚ñ≤


====================================================================================================
‚úÖ COMPLETE
====================================================================================================
