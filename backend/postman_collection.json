{
    "info": {
        "_postman_id": "dsa-multiplayer-collection",
        "name": "DSA Multiplayer API",
        "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
    },
    "item": [
        {
            "name": "Auth",
            "item": [
                {
                    "name": "Login (Get Token)",
                    "event": [
                        {
                            "listen": "test",
                            "script": {
                                "exec": [
                                    "var jsonData = pm.response.json();",
                                    "pm.environment.set(\"token\", jsonData.data.token);"
                                ],
                                "type": "text/javascript"
                            }
                        }
                    ],
                    "request": {
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"email\": \"admin@example.com\",\n    \"password\": \"password123\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/auth/login",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "auth",
                                "login"
                            ]
                        }
                    },
                    "response": []
                }
            ]
        },
        {
            "name": "Questions",
            "item": [
                {
                    "name": "Get All Questions",
                    "request": {
                        "method": "GET",
                        "header": [],
                        "url": {
                            "raw": "{{baseUrl}}/api/questions",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "questions"
                            ]
                        }
                    },
                    "response": []
                },
                {
                    "name": "Create Questions (Global)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"questions\": [\n        {\n            \"question\": {\n                \"title\": \"The Time Traveler's Paradox Resolver\",\n                \"description\": \"...\",\n                \"points\": 180,\n                \"difficulty\": \"HARD\",\n                \"functionName\": \"findParadoxes\",\n                \"slug\": \"time-traveler-paradox-resolver\",\n                \"testCases\": [],\n                \"templates\": []\n            }\n        }\n    ]\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/questions",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "questions"
                            ]
                        }
                    },
                    "response": []
                }
            ]
        },
        {
            "name": "Submissions - Time Traveler Paradox",
            "item": [
                {
                    "name": "Run - Time Traveler Paradox (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findParadoxes(n: int, k: int, requests: List[List]) -> Dict:\\n    # Sample Solution Logic for Test\\n    # Sort by start time\\n    requests.sort(key=lambda x: x[0])\\n    paradoxes = []\\n    \\n    for i in range(len(requests)):\\n        for j in range(i + 1, len(requests)):\\n            r1 = requests[i]\\n            r2 = requests[j]\\n            \\n            start1, end1, id1 = r1\\n            start2, end2, id2 = r2\\n            \\n            # Check overlap\\n            overlap = min(end1, end2) - max(start1, start2)\\n            if overlap > k:\\n                if id1 < id2:\\n                    paradoxes.append([id1, id2])\\n                else:\\n                    paradoxes.append([id2, id1])\\n    \\n    # Remove duplicates and sort\\n    unique_paradoxes = sorted(list(set(tuple(p) for p in paradoxes)))\\n    \\n    return {\\n        'count': len(unique_paradoxes),\\n        'paradoxPairs': unique_paradoxes\\n    }\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/run-function/d0d77bd7-2124-4172-9d91-d3aa902264b4",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "run-function",
                                "d0d77bd7-2124-4172-9d91-d3aa902264b4"
                            ]
                        }
                    },
                    "response": []
                },
                {
                    "name": "Submit - Time Traveler Paradox (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findParadoxes(n: int, k: int, requests: List[List]) -> Dict:\\n    # Sample Solution Logic for Test\\n    # Sort by start time\\n    requests.sort(key=lambda x: x[0])\\n    paradoxes = []\\n    \\n    for i in range(len(requests)):\\n        for j in range(i + 1, len(requests)):\\n            r1 = requests[i]\\n            r2 = requests[j]\\n            \\n            start1, end1, id1 = r1\\n            start2, end2, id2 = r2\\n            \\n            # Check overlap\\n            overlap = min(end1, end2) - max(start1, start2)\\n            if overlap > k:\\n                if id1 < id2:\\n                    paradoxes.append([id1, id2])\\n                else:\\n                    paradoxes.append([id2, id1])\\n    \\n    # Remove duplicates and sort\\n    unique_paradoxes = sorted(list(set(tuple(p) for p in paradoxes)))\\n    \\n    return {\\n        'count': len(unique_paradoxes),\\n        'paradoxPairs': unique_paradoxes\\n    }\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/submit-function/d0d77bd7-2124-4172-9d91-d3aa902264b4",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "submit-function",
                                "d0d77bd7-2124-4172-9d91-d3aa902264b4"
                            ]
                        }
                    },
                    "response": []
                }
            ]
        },
        {
            "name": "Submissions - Spell Combiner Challenge",
            "item": [
                {
                    "name": "Run - Spell Combiner (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findBestSpellPair(n: int, spells: List[str]) -> Dict:\\n    max_res = -1\\n    best_pair = (-1, -1)\\n    \\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            # Calculate LCS length\\n            s1, s2 = spells[i], spells[j]\\n            m, l = len(s1), len(s2)\\n            dp = [[0] * (l + 1) for _ in range(m + 1)]\\n            \\n            for x in range(1, m + 1):\\n                for y in range(1, l + 1):\\n                    if s1[x - 1] == s2[y - 1]:\\n                        dp[x][y] = dp[x - 1][y - 1] + 1\\n                    else:\\n                        dp[x][y] = max(dp[x - 1][y], dp[x][y - 1])\\n            \\n            res = dp[m][l]\\n            if res > max_res:\\n                max_res = res\\n                best_pair = (i, j)\\n    \\n    return {\\n        'spell1Index': best_pair[0],\\n        'spell2Index': best_pair[1],\\n        'resonance': max_res\\n    }\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/run-function/03be3ae8-5027-4f30-9c45-abec79ef9816",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "run-function",
                                "03be3ae8-5027-4f30-9c45-abec79ef9816"
                            ]
                        }
                    },
                    "response": []
                },
                {
                    "name": "Submit - Spell Combiner (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findBestSpellPair(n: int, spells: List[str]) -> Dict:\\n    max_res = -1\\n    best_pair = (-1, -1)\\n    \\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            # Calculate LCS length\\n            s1, s2 = spells[i], spells[j]\\n            m, l = len(s1), len(s2)\\n            dp = [[0] * (l + 1) for _ in range(m + 1)]\\n            \\n            for x in range(1, m + 1):\\n                for y in range(1, l + 1):\\n                    if s1[x - 1] == s2[y - 1]:\\n                        dp[x][y] = dp[x - 1][y - 1] + 1\\n                    else:\\n                        dp[x][y] = max(dp[x - 1][y], dp[x][y - 1])\\n            \\n            res = dp[m][l]\\n            if res > max_res:\\n                max_res = res\\n                best_pair = (i, j)\\n    \\n    return {\\n        'spell1Index': best_pair[0],\\n        'spell2Index': best_pair[1],\\n        'resonance': max_res\\n    }\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/submit-function/03be3ae8-5027-4f30-9c45-abec79ef9816",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "submit-function",
                                "03be3ae8-5027-4f30-9c45-abec79ef9816"
                            ]
                        }
                    },
                    "response": []
                }
            ]
        },
        {
            "name": "Submissions - Lost Treasure Map",
            "item": [
                {
                    "name": "Run - Lost Treasure Map (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findSafestPath(n: int, routes: List[List[int]], threshold: int) -> Dict:\\n    # Sample Dijkstra logic\\n    adj = {i: [] for i in range(n)}\\n    for u, v, w in routes:\\n        if w <= threshold:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n            \\n    pq = [(0, 0, [0])] # danger, curr, path\\n    visited = set()\\n    \\n    while pq:\\n        d, u, path = heapq.heappop(pq)\\n        \\n        if u == n - 1:\\n            return {'totalDanger': d, 'path': path}\\n            \\n        if u in visited:\\n            continue\\n        visited.add(u)\\n        \\n        for v, w in adj[u]:\\n            if v not in visited:\\n                heapq.heappush(pq, (d + w, v, path + [v]))\\n                \\n    return {'totalDanger': -1, 'path': []}\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/run-function/e4de74c6-ae7e-4038-a244-a3a1367d538c",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "run-function",
                                "e4de74c6-ae7e-4038-a244-a3a1367d538c"
                            ]
                        }
                    },
                    "response": []
                },
                {
                    "name": "Submit - Lost Treasure Map (Python)",
                    "request": {
                        "auth": {
                            "type": "bearer",
                            "bearer": [
                                {
                                    "key": "token",
                                    "value": "{{token}}",
                                    "type": "string"
                                }
                            ]
                        },
                        "method": "POST",
                        "header": [
                            {
                                "key": "Content-Type",
                                "value": "application/json"
                            }
                        ],
                        "body": {
                            "mode": "raw",
                            "raw": "{\n    \"language\": \"python\",\n    \"userFunctionCode\": \"def findSafestPath(n: int, routes: List[List[int]], threshold: int) -> Dict:\\n    # Sample Dijkstra logic\\n    adj = {i: [] for i in range(n)}\\n    for u, v, w in routes:\\n        if w <= threshold:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n            \\n    pq = [(0, 0, [0])] # danger, curr, path\\n    visited = set()\\n    \\n    while pq:\\n        d, u, path = heapq.heappop(pq)\\n        \\n        if u == n - 1:\\n            return {'totalDanger': d, 'path': path}\\n            \\n        if u in visited:\\n            continue\\n        visited.add(u)\\n        \\n        for v, w in adj[u]:\\n            if v not in visited:\\n                heapq.heappush(pq, (d + w, v, path + [v]))\\n                \\n    return {'totalDanger': -1, 'path': []}\"\n}"
                        },
                        "url": {
                            "raw": "{{baseUrl}}/api/submissions/submit-function/e4de74c6-ae7e-4038-a244-a3a1367d538c",
                            "host": [
                                "{{baseUrl}}"
                            ],
                            "path": [
                                "api",
                                "submissions",
                                "submit-function",
                                "e4de74c6-ae7e-4038-a244-a3a1367d538c"
                            ]
                        }
                    },
                    "response": []
                }
            ]
        }
    ],
    "variable": [
        {
            "key": "baseUrl",
            "value": "http://localhost:3004",
            "type": "string"
        },
        {
            "key": "token",
            "value": "",
            "type": "string"
        }
    ]
}